> 프로젝트 소개

* vue-cli를 사용하여 초기 프로젝트 디렉토리 구축
* vue2, vue-router2, Element-ui, express, webpack2 및 gulp를 사용하여 프로젝트 개발 환경 구축
* Vue, Element-ui를 사용하여 프론트 엔드가 데이터 처리를 위해 페이지 및 Vuex를 빌드하고, 백엔드가 등록, 로그인, 로그 아웃, 로그인 상태 쿼리를 작성하는 Express를 사용하여 편안한 API
현재 세션 로그인과 토큰 로그인으로 구분됩니다.
* 페이지는 등록 페이지, 로그인 페이지, 홈 페이지입니다.

> 자세한 내용을 포함한 내용 및 파일 변경 사항

1. package.json의 패키지 종속성에는 추가 npm 패키지가 포함되어 있습니다
2. config / index.js는 요청 포트 프록시를 설정하고 서버 포트 (8080 => 3000)에 대한 도메인 간 액세스를 설정합니다.
3. 서버는 서버 측 라우팅, API 인터페이스, mongodb 구성 작업입니다.
라우팅, 구성 요소를 포함하여 주요 문서의 Src vue 응용 프로그램 ...
5. gulpfile.js는 서버를 다시 시작하고 브라우저 새로 고침 작업을 늘립니다.
6. server.js 서버 시작 파일

> 프로젝트 구분

1. 해당 src와 server 앞과 뒤의 세션 로그인
2. 해당 src 토큰 및 서버 토큰 앞과 뒤의 토큰 로그인
3 명시 적으로 주로 정적 리소스 위치로 현재 디렉토리를 설정, 다른 src_index.html에 루트 디렉토리를 통해 index.html, 순서대로 프로젝트를 달성하기 위해

> 운전 지침

```쉘
npm install 설치 의존성

npm run dev webpack을 사용하여 프런트 엔드 자원의 패키지 컴파일을 엽니 다.

npm 서버 실행 서버를 시작하고 브라우저를 엽니 다.
```

여기서는 두 개의 명령 줄 창을 열어야하는데 하나는 프론트 엔드 컴파일 용이고 다른 하나는 서버 측 작업 흐름 용입니다.

> 환경 상세한 솔루션 아이디어를 구축

[프런트 엔드 핫 업데이트, 백 엔드 서비스 다시 시작, 자동 브라우저 새로 고침] (http://selvinpro.com/2017/03/20/browser-reload/#more)

- [x] 기본 로그인 쿠키 && 세션 구현
- [x] 독립형 시스템 로그인 토큰
- [] 타사 로그인 access_token




---



> 등록 / 로그인 / 로그 아웃에 대한 세부 정보

I. [로깅 구현 원리] (# 1)
두. [몇 가지 방법을 달성하는 로그인 기능] (# 2)
3. 기본 로그인 쿠키 && 세션 세부 정보 (# 3)
[토큰 로그인 정보] (# 4)

<h3 id = "1"> I. 로그인 기능의 원리 </ h3>

브라우저 사용자 양식이 서버에 세션을 생성하기 위해 제출, 식별 정보가 서버로 전송하고, 서버 측이 해당 데이터가, 그들을 비교하고, 일반적으로이 데이터를 설정해야 올바른 사용자인지 식별 ​​할 수 긴 저장, 사용자 인증 시간의 길이가 일 때,이 기간 후에는 실패합니다, 당신은 그래서 여기 ** ** ** ** 서버 브라우저 정보 정보 필요한 네 가지 핵심 포인트는 다시 로그인해야, ** 두 정보 비교 **, ** 노화 설정 **.

<h3 id = "1"> 로그인 기능을 달성하는 두 가지 방법 </ h3>

1. 기본 로그인 쿠키 && 세션
   브라우저 사용자가 양식을 제출 한 후, 서버는 사용자 정보 양식 (등 메모리, 데이터베이스, 테이블 세션 캐시)에 그 존재의 세션 테이블, 다음 방법 쿠키 (쿠키 sessionId가있다 및 해당 값) 반환을 받아 들인다 브라우저로, 너무 오래 쿠키 서버 설정이 실패하지으로,이 시간, 서버가 제대로 (sessionID와 파괴 서버 측에) 로그인을 반복하지 않는 사용자 정보를 식별 할 수있을 것입니다

   * 서버 측에서 생성 한 세션 ID
   * 서버 측 및 클라이언트 측 저장 세션 ID
   * HTTP 헤더에서 세션 ID 추출
   * 요청자 ID 정보를 얻기위한 서버 측 해시의 세션 ID에 따라

2. 토큰 (JSON 웹 토큰)

   참조 :

   [JSON 웹 토큰 세부 정보] (http://blog.leapoahead.com/2015/09/06/understanding-jwt/)

   [여덟 개 만화는 JSON 웹 토큰 디자인 SSO의 사용을 이해] (http://blog.leapoahead.com/2015/09/07/user-authentication-with-jwt/)

   어떤 정보를 유저가 폼 (사용자 이름을 포함하는, 암호), 서버는 페이로드로 JWT userId를 저장하는 사용자 이름 (부하), 헤드는 따라서 JWT 형성 접합 용 Base64 인코딩, 서명을 수신 제출, 다시 브라우저에 쿠키에 저장하고, 노화, 때 브라우저 각 요청, 그래서 사용자의 데이터베이스에 비해 JWT의 암호를 해독 할 수있는 서버, 확인 후 쿠키의 만료 전에 JWT를 수행한다 설정들은 반품 요청

   * cookie && session은 서버가 sessionId (메모리, 데이터베이스 등)를 저장하는 독립적 인 메커니즘을 제공해야합니다.
   * 쿠키 && 토큰은 추가 저장 서버를 필요로하지 않지만 암호화, 암호 해독, 인코딩 및 기타 작업이 향상되었습니다.

   > 싱글 사인온 (사이트 로그인, 나머지 사이트는 로그인 할 수 있음)

   * cookie && session sessionId는 서버에 저장되므로 여러 도메인 이름 아래의 서버가 sessionId를 동기화해야합니다.
   * JWT가 쿠키를 통해 전달되며, 추가 저장을 필요로하지 않습니다, 도메인 이름은 최상위 도메인 이름으로 설정됩니다 쿠키 JWT를 포함 할 필요가 도메인 이름의 보편적 접근,이 쿠키는 JWT를 포함


제 3 자 :`access_token`



<h3 id = "3"> 세 가지 기본 로그인 쿠키 && 세션 세부 정보 </ h3>

1. 몽구스 기본 색인 데이터 모델을 구축하고,이 경우에, 우리는 또한, 대응하는 미들웨어가 사용될 수있다 레디 스 MongoDB를 등을 시도하는 서버 메모리 저장 sessionId가를 이용해, 이름 고유 속성을 설정.

2. POST에 로그인하십시오 :`/ api / login`
  어떻게 사용자 입력 폼 클릭 로그인하면, 우리는`pos`t` / API / 로그인 ', 요청을 개시 한 전단 VUE 로그인 상태를 식별하는'/는 '컨트롤러 대응 프로세스 단계는 수행 로그인 / API

  * 요청은 사용자 정보 (사용자 이름, 암호)를 포함하고, mogoose 인스턴스를 생성합니다.

  * mongoDB에이 사용자 이름 정보를 입력하십시오 (사용자의 Skema 모델은 고유 색인으로 이름이 설정되었으므로 반복 할 수 없습니다)

  * 해당 사용자 이름을 반환하지 않으며 데이터베이스에서 암호를 찾고이 암호와 비교합니다 (몽구스 인스턴스 생성시 암호 sha1 암호화).

  * 암호가 정확하고 정확한 정보를 반환하고 세션을 작성하십시오.

        // 사용자 정보를 세션에 넣습니다.
        delete user.password;
        req.session.user = user;

  * 암호 일치가 실패했습니다. 그렇지 않으면 암호가 잘못되었습니다.

    / api / register, / api / user 등이 req.session.user 존재 여부에 따라 로그인 로그 아웃 상태를 변경할지 여부를 결정합니다.

    ```자바 스크립트
    checkLogin (req, res, next) {
        if (! req.session.user) {
          return res.json ({
             오류 : '로그인하지 않았습니다'
          });
        }
        다음 ();
      },

      checkNotLogin (req, res, next) {
        if (req.session.user) {
          return res.json ({
            오류 : '로그인'
          });
        }
        다음 ();
      }
    ```

    과정을 통해 실행할 때이 시점에서, 우리는 다음 점프를 달성 할 수 있으며, 사용자 정보가 전면 채우기`localstorage``의 VUE-router`, 다른 페이지에 대한 그것의 사용에 의해 인수, 로그인 정보에 성공적으로 수익을 얻을 수 있었다 데이터.

3. POST 등록 :`/ api / register`

   등록 기능은 등록 양식을 작성할 때와 마찬가지로 '/ api / register'에 해당하는 컨트롤러가 제출 한 데이터를 수락합니다.

   * OBJECTID 투 timestamp` 인스턴스가이 예를 들어, 시간 포맷, 즉, 작성 시간을 변환된다 objectID에`통해 (SHA1가 여기에 사용된다), 몽구스 예를 생성하고, 사용자 이름 및 암호와 암호화 된 패스워드에 의해 요청 오기 ** 특정 질문 **을 볼 수 있습니다.
   * 고유 한 이름 특성을 통해 데이터베이스 쿼리에 사용자 이름이 적절한 데이터를 반환하도록 등록되었는지 확인합니다.

4. 로그 아웃 GET :`/ api / user`


   이 API의 역할은 로그 아웃 기능을 수행하는 것입니다. 로그 아웃을 클릭하면 액시즈를 통해이 API에 액세스하고 API에 해당하는 컨트롤러가 다음 코드를 실행합니다.

   ```자바 스크립트
   // 사용자 세션 삭제
   req.session.user = null;
   res.json ({
     메시지 : '성공적으로 로그 아웃'
   })
   ```
5. 로그인 상태 판단

    Axios의 인터셉터를 사용 checkLogin 기능에 의해 후단 세션, 반환 상태 sesssion 존재 여부를 판단 Axios의 점프 응답 차단제, 특정 코드 페이지를 '제공. / src에은 / UTIL / interceptor.js`


<h3 id = "4"> 4. 토큰 로그인 세부 사항 </ h3>

* 등록 및 세션 세션의 기본 실현, 토큰 속성을 추가하는 데이터베이스 모델 이외에, 그리고 기본 로그인 상태가 다릅니다

* 동일한 Axios의 인터셉터를 사용하여 토큰 상태를 반환 제공된 유효 기간을 획득하기 위해 주로 후단 checkToken 요청 토큰 디코딩 수행 선단부 토큰 판정 로그인 상태를 사용하여, 요청 인터셉터에 헤더를 추가 승인 토큰, 응답 인터셉터에서 판단을 설정합니다.

---





> 세부 질문

1. objectid-timestamp 패키지 역할

   먼저 각 문서 (각 데이터 행의 행에있는 MySQL)의 MongoDB`ObjectId`를 이해하고`_id` 속성을 포함하며 속성 값은`ObjectId`입니다.

   ObjectId는 다음 형식의 12 바이트 BSON 유형 데이터입니다.

   - 처음 4Y이트는 시간 소인을 나타냄니다 (** 데이터 작성 시간 **)
   - 다음 3 바이트는 컴퓨터 ID입니다
   - 다음 두 바이트는 프로세스 ID (PID)
   - 마지막 3 바이트는 임의의 숫자입니다.

   그래서 그 역할은 처음 네 바이트를 시간 형식으로 변환하는 것입니다.

2. 브라우저가 새로 고쳐지면 vuex 유지 관리의 전역 상태가 사라집니다.

  * vuex의 역할 및 일부 저장소에 로컬 상태 데이터를 사용하는 중요성 이해
  * vuex 상태 관리는 유지 보수성 및 확장 성을위한 것이며 로컬 캐시는 아무 관련이 없습니다.
  * [자세한 내용은 github 문제를 볼 수 있습니다] (https://github.com/vuejs/vuex/issues/47)

3. 라우팅 차단 세부 정보의 Vue-router

  ```자바 스크립트
    router.beforeEach ((to, from, next) => {
      다음 ({
          경로 : '/ login',
          검색어 : {
              리디렉션 : to.fullPath
          }
      })
    })
    // vue-router 네비게이션 훅 함수 beforeEach
    to : 입력 할 경로 객체
    from : 현재 네비게이션이 경로를 벗어나려고합니다.
    다음 : 호출 next (), beforeEach이 후크를 호출, 후크 함수가 끝났다고 말했고, 동시에 몇 가지 점프를 설정할 수 있습니다.

    경로 : 리디렉션 할 경로를 나타냅니다.
    query : 경로 url의 매개 변수
    fullPath : 구문 분석 된 URL. 쿼리 매개 변수와 해시의 전체 경로가 들어 있습니다.

    검색어 : {
        리디렉션 : to.fullPath
    }

    즉, 현재 경로에서 쿼리 매개 변수 redirect를 추가하고 redirect to.fullPath의 값을 추가하면,
    to.fullPath는 점프하기 전의 경로 URL을 나타냅니다.

  ```